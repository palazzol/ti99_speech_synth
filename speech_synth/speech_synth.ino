
#include <string.h>

// Pin definitions
int DATA_pin[] = {2,3,4,5,6,7,8,9};
int A_pin = 10;
int B_pin = 11;
int G1_pin = 12;
int G2B_pin = A0;
int RDY_pin = A1;

int LED_pin = 13;

// Commands
int speak[] = {0,1,0,1,0,0,0,0};
int addr[] = {0,1,0,0,0,0,0,0};
int reset[] = {1,1,1,1,1,1,1,1};
int readbyte_cmd[] = {0,0,0,1,0,0,0,0};
int speak_external[] = {0,1,1,0,0,0,0,0};
   
void setup() {      
  for (int i = 0;i<8;i++)
  {
    pinMode(DATA_pin[i], OUTPUT);
  }
  pinMode(G1_pin, OUTPUT);       
  pinMode(A_pin, OUTPUT);       
  pinMode(G2B_pin, OUTPUT);       
  pinMode(LED_pin, OUTPUT);       
  pinMode(B_pin, OUTPUT);       
  pinMode(RDY_pin, INPUT_PULLUP);    

// OFF
  digitalWrite(G1_pin,LOW); 
  digitalWrite(G2B_pin,LOW); 
  digitalWrite(A_pin,LOW); 
  digitalWrite(B_pin,HIGH);

  Serial.begin(115200);
  Serial.println("TI speech synth code");
  //write_rst();
  //write_addr(0);

  //do_reset_command();
  //do_reset_command();
  //do_reset_command();
  do_reset_command();

  wait_for_ready();

  Serial.println("reset");

    //do_load_address(9);
    //do_load_address(14);
    //do_load_address(7);
    //do_load_address(7);
    //do_load_address(0);
    delay(1000);
}

void loop() {
    print_ready_status();

    /*
    // Speak one sample
    do_load_address(9);
    do_load_address(14);
    do_load_address(7);
    do_load_address(7);
    do_load_address(0);
    do_speak_command();

    delay(10000);
    */
    
    /*
    // Match a String
    do_speak_entry("THAT IS INCORRECT");
    */

    Serial.println("Speaking...");
    /*
    // Magenta from TI99 speech synth rom
    char sample[] = { 0xa2,0xa0,0x26,0xf2,0xcd,0x9d,0xb4,0x4e,0xc5,0x68,0xe7,0x4a,0xb4,0xba,0x10,0xb5,0x83,0xbd,0xf7,0xe9,0x72,0xb4,0x54,0x93,0x4e,0xa5,0x8b,0x9e,0xcd,0xd8,0x72,0x8a,0x1e,0xdb,0xd8,0x71,0xb3,0xc9,0x6,0x2a,0x2b,0x33,0xca,0x96,0x2,0x1a,0x41,0xb6,0xc0,0xaa,0x6a,0x34,0x13,0xf1,0x37,0x2b,0xd,0x4e,0xd3,0xa3,0x2a,0xad,0xd4,0x7,0x1d,0xb7,0x91,0xb9,0x52,0x1f,0x2d,0xd5,0xcb,0x76,0x4f,0x4d,0xce,0x8d,0x5d,0x53,0x5a,0x36,0x40,0xb1,0x2a,0x6,0xf0,0xd8,0x6d,0xd5,0x21,0x49,0xab,0x4e,0xea,0xdb,0xad,0xc9,0x27,0x9d,0x90,0x5c,0x92,0x66,0x17,0x3c,0x4a,0x35,0x72,0x5a,0x43,0x36,0x2f,0x8a,0x4a,0x69,0x8d,0x85,0x33,0x2c,0x94,0x9a,0xd9,0x26,0xb5,0xe0,0xb2,0xf2};
    int sample_len = 0x80;
    */

    // AFTER from TI99 speech synth rom
    char sample1[] = { 0x25,0x8b,0x23,0xc3,0xa1,0xc3,0x9c,0x2c,0xf6,0x32,0xe7,0xaa,0x7a,0xb3,0x9b,0xdf,0xe2,0x56,0xb5,0x31,0x80,0x15,0xc6,0x1a,0xd0,0x0,0x80,0x1,0x8a,0x32,0x4f,0x85,0x5f,0xec,0x96,0x9a,0xbd,0xd7,0xb5,0xcb,0x83,0x1b,0xec,0xa0,0x88,0x8c,0x74,0x62,0xb4,0x3,0xaa,0x2c,0x12,0xb3,0xc9,0x76,0xd6,0xcc,0x70,0xf2};
    int sample_len1 = 0x3c;

    // AFTER from term em 2, intercepted in MAME
    char sample2[] = {       0x2e, 0x8a, 0x2d, 0xca, 0xb8, 0x9a, 0xac, 
                     0x28, 0xb6, 0x28, 0xe3, 0x6a, 0x72, 0xa3, 0x1b, 
                     0xad, 0x28, 0xb6, 0x28, 0xe3, 0x6a, 0x12, 0x01, 
                     0x02, 0x14, 0x13, 0xc6, 0x01, 0x0b, 0x78, 0x20, 
                     0x01, 0xc5, 0x84, 0x69, 0x00, 0x20, 0x00, 0x3b, 
                     0x8a, 0x07, 0xe0, 0x58, 0x0f, 0x03, 0xa4, 0x50, 
                     0x9c, 0x22, 0x37, 0x94, 0xab, 0xcc, 0x7b, 0x8b, 
                     0xdc, 0x50, 0xae, 0x32, 0xef, 0x3d, 0x4a, 0x91, 
                     0x1b, 0xca, 0x55, 0xe6, 0xfd, 0x01 };
    int sample_len2 = 0x45;
    /*
    char sample3[] = { 0x04, 0x30, 0x3a, 0xbc, 0x2d, 0xd1, 0x17, 0xab, 0x6e, 0x91, 0xb2, 0x07, 0x95, 0xa2, 0x1e, 0x49, 
                      0x14, 0x60, 0x94, 0xab, 0x02, 0xb2, 0x37, 0x33, 0x40, 0x4a, 0x65, 0x06, 0x60, 0x5b, 0x7c, 0xf5, 
                      0x7e, 0x99, 0x68, 0x76, 0xe5, 0x35, 0xf8, 0x1e, 0x4e, 0x52, 0x93, 0xd7, 0xe0, 0x5b, 0x3a, 0x4b, 
                      0x4c, 0x59, 0xa3, 0xaf, 0xe9, 0xac, 0x31, 0x65, 0xcd, 0x61, 0x44, 0x90, 0xd6, 0x94, 0xb5, 0xc5, 
                      0xe0, 0x4d, 0x5c, 0x95, 0xc7, 0x50, 0xc5, 0xba, 0xa8, 0xc5, 0x4e, 0xc0, 0x02, 0x96, 0x09, 0x98, 
                      0x24, 0x2b, 0x00, 0x55, 0x54, 0x29, 0x20, 0x8b, 0x52, 0x01, 0x24, 0x5e, 0x5a, 0x1a, 0xe7, 0x5b, 
                      0xc5, 0xaa, 0x76, 0x9b, 0x43, 0xf4, 0x60, 0xae, 0xc6, 0x6d, 0x09, 0xc9, 0x13, 0xb9, 0x1b, 0x97, 
                      0xd5, 0x67, 0x37, 0x96, 0xaa, 0x5d, 0x56, 0xcd, 0x2b, 0xd2, 0x2c, 0x71, 0xd8, 0x3d, 0x8b, 0xcc, 
                      0xf0, 0x24, 0x6d, 0x0a, 0x5e, 0xdc, 0x2a, 0x6b, 0x8f, 0x35, 0x38, 0x4e, 0xaf, 0xac, 0xd5, 0x56, 
                      0x1f, 0x39, 0xbc, 0xaa, 0x56, 0x59, 0x7d, 0xb0, 0x50, 0x8d, 0x46, 0x69, 0x37, 0x2e, 0xcc, 0xc5, 
                      0x1a, 0x97, 0xd5, 0x67, 0x33, 0x95, 0x6c, 0xdc, 0x16, 0x9f, 0x25, 0x34, 0xab, 0xf6, 0x58, 0x63, 
                      0xa2, 0xb0, 0x9a, 0xc8, 0x63, 0x0b, 0x91, 0xad, 0x62, 0xac, 0x94, 0xc3, 0xeb, 0xd0, 0x88, 0xb2, 
                      0x9d, 0xd6, 0x2c, 0x42, 0x3c, 0x2c, 0x4e, 0xf9, 0x82, 0x08, 0x8b, 0x2c, 0xdb, 0x0a, 0x80, 0x35, 
                      0xb3, 0xfc, 0xde, 0x4a, 0x74, 0xa5, 0x25, 0x03, 0xd0, 0x62, 0x5d, 0x5e, 0x13, 0x3c, 0x33, 0x2a, 
                      0x52, 0xfa, 0xbc, 0x0d, 0x77, 0xcf, 0x84, 0xe1, 0x0f, 0xca, 0xdd, 0xd5, 0x5b, 0x31, 0x40, 0x45, 
                      0x13, 0x06, 0x98, 0xe2, 0x42, 0x00, 0xa3, 0xc3, 0xe0, 0x01, 0x00, 0x00, 0x60, 0x21, 0xd4, 0x21, 
                      0x2d, 0x2b, 0x15, 0x0f, 0x5f, 0x17, 0x8f, 0xae, 0xb4, 0xb5, 0x3c, 0xd3, 0x22, 0x37, 0x32, 0xf2, 
                      0x71, 0x7d, 0xb2, 0xdc, 0x6c, 0x2b, 0xc7, 0x4d, 0xd6, 0xa2, 0x72, 0xad, 0x14, 0x3f, 0x5a, 0xf1, 
                      0xcc, 0xa6, 0x54, 0xc2, 0x60, 0x54, 0xd3, 0x42, 0x4a, 0x88, 0x32, 0x75, 0x35, 0x4f, 0xd3, 0x0c, 
                      0xa0, 0x3a, 0x8c, 0x01, 0x4c, 0x6a, 0x08, 0x80, 0x4b, 0x37, 0x01, 0x28, 0xa6, 0xb2, 0x74, 0x3f, 
                      0xcd, 0x43, 0x3a, 0xec, 0x30, 0xfc, 0x51, 0x8f, 0xe8, 0x4a, 0xcb, 0x0c, 0xdb, 0xdc, 0x7d, 0xaa, 
                      0x2e, 0x33, 0x6c, 0x89, 0x88, 0x09, 0xbb, 0xac, 0xb0, 0xc5, 0x33, 0x26, 0xec, 0xb2, 0xc2, 0xb6, 
                      0xf0, 0x68, 0xb3, 0xcb, 0x0e, 0xcb, 0x22, 0xbc, 0xcd, 0x2d, 0x3b, 0x76, 0x2d, 0xcb, 0x96, 0x7a, 
                      0xdc, 0x54, 0xb8, 0xac, 0x4b, 0xce, 0xf2, 0x82, 0xd7, 0x29, 0x6f, 0xb9, 0x25, 0x0c, 0x4e, 0x3c, 
                      0xbd, 0x22, 0xa5, 0x28, 0x29, 0x37, 0x55, 0xb3, 0x62, 0x00, 0xa7, 0x42, 0x15, 0xa0, 0x48, 0x39, 
                      0x01, 0x80, 0x37, 0x53, 0x80, 0x15, 0x69, 0xcb, 0x4f, 0xda, 0x74, 0x33, 0x8d, 0xac, 0x20, 0x5b, 
                      0xf6, 0xad, 0x36, 0xb2, 0xc2, 0x62, 0x39, 0x2a, 0x87, 0xf2, 0x89, 0xaa, 0x67, 0xab, 0x5c, 0x29, 
                      0x27, 0xaa, 0x51, 0xcc, 0x6b, 0xa9, 0xac, 0xb8, 0x44, 0x51, 0xef, 0x95, 0x52, 0x12, 0xe5, 0x32, 
                      0x4a, 0xc2, 0xca, 0x4a, 0xb2, 0x14, 0xaf, 0x1c, 0x29, 0x2b, 0xa9, 0x86, 0xa2, 0x22, 0x94, 0x8c, 
                      0x24, 0x2b, 0xca, 0xd3, 0x90, 0x5a, 0x52, 0x65, 0xcb, 0x8b, 0xdd, 0x76, 0xc8, 0x84, 0xa9, 0x68, 
                      0x33, 0xc7, 0x21, 0xf7, 0xda, 0x3d, 0xdd, 0xe2, 0x8c, 0xcc, 0x77, 0x0b, 0x8f, 0x29, 0x3c, 0x52, 
                      0xdf, 0xb5, 0x34, 0x37, 0xcc, 0x48, 0xc3, 0xd4, 0x92, 0x5e, 0xcb, 0x2d, 0x09, 0x5b, 0xca, 0xa6, 
                      0xad, 0x8c, 0x24, 0x2c, 0x4d, 0xab, 0xb1, 0x32, 0xe2, 0x30, 0xac, 0xa4, 0xdb, 0xca, 0x8a, 0x43, 
                      0xf5, 0xe1, 0x2e, 0x3b, 0x27, 0x8e, 0xc5, 0xda, 0xb2, 0x65, 0xaf, 0x38, 0x06, 0x19, 0xaf, 0x96, 
                      0xbc, 0xe2, 0xe8, 0x64, 0x7d, 0x92, 0x4e, 0x8b, 0xb3, 0xc7, 0x8a, 0x6a, 0xb1, 0x2e, 0x0e, 0xc2, 
                      0xc4, 0x22, 0x1c, 0xbb, 0xb8, 0x08, 0x37, 0x73, 0x93, 0xfd, 0x00, 0xf7, 0xa9, 0xff};
    int sample_len3 = 0x23d;
    */
    
    do_speak_external();
    for(int i=0;i<sample_len1;i++) {
      int s = read_status();
      while(!(s & 0x40))
        s = read_status();
      //Serial.println(s, BIN);
      do_write_data(sample1[i]);
    }
    Serial.println("Speaking complete");
    delay(1000);

    do_speak_external();
    for(int i=0;i<sample_len2;i++) {
      int s = read_status();
      while(!(s & 0x40))
        s = read_status();
      //Serial.println(s, BIN);
      do_write_data(sample2[i]);
    }
    Serial.println("Speaking complete");
    delay(1000);
    
    /*
    // Dump the ROM
    int b = 0;
    for(int i=0; i<2048; i++)
    { 
      for(int j=0;j<16;j++) {
        b = do_readbyte_command();
        if (b<16)
          Serial.print('0');
        Serial.print(b,HEX);
      }
      Serial.println();
    }
    */
}

void print_ready_status()
{
  if(is_ready())
  {
    //Serial.println("ready");
    digitalWrite(LED_pin,HIGH);
  }
  else
  {
    //Serial.println("not ready");
    digitalWrite(LED_pin,LOW);
  }
}

// Helper functions

void wait_for_ready()
{
  while(!is_ready());
}

void wait_for_not_ready()
{
  while(is_ready());
}

void enable_WS()
{
  // Enable Write
  digitalWrite(A_pin,HIGH);
  digitalWrite(B_pin,HIGH);
  digitalWrite(G1_pin,HIGH);
}

void disable_WS()
{
  digitalWrite(G1_pin,LOW);
}

void enable_RS()
{
  // Enable Read
  digitalWrite(A_pin,LOW);
  digitalWrite(B_pin,HIGH);
  digitalWrite(G1_pin,HIGH);
}

void disable_RS()
{
  digitalWrite(G1_pin,LOW);
}

void data_write(int data[])
{
  for (int i = 0;i<8;i++)
  {
    digitalWrite(DATA_pin[i], data[i]);
    pinMode(DATA_pin[i], OUTPUT);
  }
}

void data_tristate()
{
  for (int i = 0;i<8;i++)
  {
    pinMode(DATA_pin[i], INPUT);
  }
}

int data_read()
{
  int rv = 0;
  for (int i = 0;i<8;i++)
  {
    rv <<= 1;
    rv |= digitalRead(DATA_pin[i]);
  }
  return rv;
}

//////

struct Node
{
  int name_len;
  char name[32];
  int prev_ptr;
  int next_ptr;
  int data_ptr;
};

void do_read_node(struct Node *node, int address)
{
  //Serial.println(address);
  
  do_load_address(address & 0x0f);
  do_load_address((address>>4) & 0x0f);
  do_load_address((address>>8) & 0x0f);
  do_load_address((address>>12) & 0x0f);
  do_load_address(0);
  //delay(10);
  node->name_len = do_readbyte_command();
  //Serial.println(node->name_len);
  
  int i;
  for(i=0;i<node->name_len;i++)
    node->name[i] = do_readbyte_command();
  node->name[i] = 0;

  Serial.println((char *)node->name);
  
  node->prev_ptr = do_readbyte_command()<<8;
  node->prev_ptr += do_readbyte_command();

  node->next_ptr = do_readbyte_command()<<8;
  node->next_ptr += do_readbyte_command();

  do_readbyte_command();

  node->data_ptr = do_readbyte_command()<<8;
  node->data_ptr += do_readbyte_command();  

  int data_len = do_readbyte_command(); // Unused
}

int do_speak_tree(char *s, int slen, int address)
{
  Node node;
  
  do_read_node(&node, address);

  int x = strncmp(s, node.name, slen);
  if (x == 0) {
    do_load_address(node.data_ptr & 0x0f);
    do_load_address((node.data_ptr>>4) & 0x0f);
    do_load_address((node.data_ptr>>8) & 0x0f);
    do_load_address((node.data_ptr>>12) & 0x0f);
    do_load_address(0);
    do_speak_command(); 
    return 0;
  } else if (x < 0) {
    if (node.prev_ptr == 0)
      return -1;
    return do_speak_tree(s, slen, node.prev_ptr);
  } else {
    if (node.next_ptr == 0)
      return -1;
    return do_speak_tree(s, slen, node.next_ptr);
  }
}
  
void do_speak_entry(char *s)
{
  int address = 1;
  int slen = strlen(s);
  int rv = do_speak_tree(s, slen, address);
  if (rv == 0)
    Serial.println("Speech OK");
  else
    Serial.println("Speech not found");
}

// Commands

void do_load_address(int addre)
{
  //Serial.print("do_load_address(");
  //Serial.print(addre);
  //Serial.println(")");
  
  addr[4] = (addre>>3)&0x01;
  addr[5] = (addre>>2)&0x01;
  addr[6] = (addre>>1)&0x01;
  addr[7] = (addre>>0)&0x01;

  data_write(addr);

  enable_WS();
  
  wait_for_not_ready();

  disable_WS();

  wait_for_ready();

  data_tristate();
}

void do_speak_external()
{
  //Serial.print("do_speak_external()");

  data_write(speak_external);

  enable_WS();
  
  wait_for_not_ready();

  disable_WS();

  wait_for_ready();

  data_tristate();
}

void do_write_data(int data)
{
  //Serial.print("do_write_data()");

  int data_as_array[] = {0,0,0,0,0,0,0,0};
  for(int i=0;i<8;i++)
    data_as_array[i] = ((data>>(7-i))&0x01);
    
  data_write(data_as_array);
  
  //delay(1);
  
  enable_WS();
  
  wait_for_not_ready();
  //Serial.println("NR");

  //delay(1);
  
  disable_WS();

  wait_for_ready();
  //Serial.println("R");

  data_tristate();  
}

void do_speak_command()
{
  data_write(speak);

  enable_WS();
  
  wait_for_not_ready();

  disable_WS();

  wait_for_ready();

  data_tristate();
}

void do_reset_command()
{
  data_write(reset);

  enable_WS();

  //Serial.println("a");
  
  //wait_for_not_ready();

  //Serial.println("b");

  disable_WS();

  //Serial.println("c");

  wait_for_ready();

  data_tristate();
  
  //Serial.println("d");
}

int do_readbyte_command()
{
  //Serial.println("do_readbyte_command()");
  
  data_write(readbyte_cmd);

  enable_WS();
  
  wait_for_not_ready();

  disable_WS();

  wait_for_ready();

  data_tristate();

  enable_RS();

  // Special
  wait_for_ready();

  int b = data_read();

  disable_RS();

  return b;
}

int read_status()
{
  enable_RS();

  // Special
  wait_for_ready();

  int b = data_read();

  disable_RS();

  return b;
}

boolean is_ready()
{
  if(digitalRead(RDY_pin))
  {
    return 1;
  }
  else
  {
    return 0;
  }
}
